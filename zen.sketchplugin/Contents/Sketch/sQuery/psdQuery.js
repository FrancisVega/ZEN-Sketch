/*The MIT License (MIT)Copyright (c) 2015 Francis VegaPermission is hereby granted, free of charge, to any person obtaining a copy ofthis software and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation the rights touse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies ofthe Software, and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS ORCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHERIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*//*@filetype psdQuery core@name psdQuery.js@author Francis Vega*//*<javascriptresource><name>psdQuery</name></javascriptresource>*///@includepath "~/JSONActionManager/"//@include "jamEngine.jsxinc"//@include "jamActions.jsxinc"//@include "jamColors.jsxinc"//@include "jamHelpers.jsxinc"//@include "jamJSON.jsxinc"//@include "jamLayers.jsxinc"//@include "jamShapes.jsxinc"//@include "jamStyles.jsxinc"//@include "jamText.jsxinc"//@include "jamUtils.jsxinc"//@include "prototypes.js"//@include "AMLibrary.js"var psdQuery, $$;(function(){    /**     * Variable que contiene el objeto PSDQUERY.     * @param {string|object} selector El selector usado en psdQuery.     * @return {psdQueryObject} Devuelve un objeto PSDQUERY.     */    psdQuery = $$ = function(selector) {        return new PSDQUERY(selector);    };    /**     * Guarda la selección actual en Photoshop.     * @return {Int:Array} Devuelve un array con los índices de las capas.     */    var savePreviousSelectionLayers = function() {        return getIndexFromSelectedLayers();    };    /**     * Selecciona en Photoshop una lista de capas basada en índices.     * @param {Int:Array} pre Un array con lo índices de las capas.     */    var loadPreviousSelection = function(layersIndexes) {        var addLayer = false;        for (i=0; i<layersIndexes.length; i++) {            if (i>0) { addLayer = true; }            selectLayerByIndex(layersIndexes[i], addLayer);        }    };    /**     * Comprueba que el selector es de tipo expresión regular.     * @param {string} query El selector introducido por el usuario.     * @param {string} name El nombre de la capa     * @return {true|undefined} Devuelve true si hay coincidencia, undefined si no     */    var isMatch = function (query, name) {        query = query.slice(1, query.length);        query = query.slice(0,(query.length)-1);        query = "^" + query + ".*";        var re = new RegExp(query, "g");        try {            return name.match(re)[0];        } catch(e) {            return undefined;        }    };    /**     * ...     * @param {...} paramName ...     * @return {...} ...     */    var PSDQUERY = function(selector) {        // psdQuery works in pixels        app.preferences.typeUnits = TypeUnits.PIXELS;        // No dialogs during script execution        // app.displayDialogs = DialogModes.NO;        // this        this.typename =  "psdQuery";        this.version = "1.0";        this.autor = "Francis Vega";        this.layers = [];        // vars        var _docs = [];        var _layers = [];        var allLayers = [];        var len;        var i;        var keyChar = "%";        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        var fillArray = function(layer) {            allLayers.push(layer);        };        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        var mixObjects = function (first, second) {            for (var prop in first) {                if (first[prop] !== "" && first[prop] !== undefined && first[prop] !== null ) {                    second[prop] = first[prop];                }            }            return second;        };        // Save current activeLayer        // var prevLayers = savePreviousSelectionLayers();        if (typeof selector === "string") {            switch(selector) {                case "*":                    // All                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // copy array                    _layers = allLayers.slice();                    break;                case "%document%":                    // Document                    this.activeDocument = app.activeDocument;                    _layers = [];                    _layers.push(app.activeDocument);                    break;                case "%app%":                    // App                    this.app = app;                    _layers = [];                    _layers.push(app);                    break;                case "%artLayers%":                    // Art layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter art layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isArtLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%textLayers%":                    // Text layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter text layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isTextLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case  "%paragraphTextLayers%":                    // Paragraph text layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter paragraph text layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isParagraphTextLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case  "%pointTextLayers%":                    // Point text layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter point text layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isPointTextLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%shapeLayers%":                    // Save current selection                    var prevLayers = savePreviousSelectionLayers();                    // Vector layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter vector layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isShapeLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    // Restore selection                    loadPreviousSelection(prevLayers);                    break;                case "%bitmapLayers%":                    // Bitmaps layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter vector layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isNormalLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%smartObjects%":                    // Smartobjects                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter smartobjects layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isSmartObjectLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%adjustementLayers%":                    // Adjustement layers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter adjustement layers                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isAdjustementLayer(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%groups%":                    // Groups                    // Fill array allLayers                    allLayers = [];                    traverseLayersAMFlat(fillArray);                    // Filter groups                    _layers = [];                    len = allLayers.length;                    for (i=0; i<len; i++) {                        if(this.isLayerSet(allLayers[i])) {                            _layers.push(allLayers[i]);                        }                    }                    break;                case "%selected%":                    // Selected (UI) Layers                    // Index of selected layers                    var selectedLayers = getIndexFromSelectedLayers();                    _layers = [];                    // Hacemos activa la capa una por una y la vamos guardando en un array de objetos de capa                    for (i=0; i<selectedLayers.length; i++) {                        selectLayerByIndex(selectedLayers[i]);                        _layers.push(app.activeDocument.activeLayer);                    }                    // Restablecemos la selección original                    var add = false;                    for (i=0; i<selectedLayers.length; i++) {                        if (i>0) { add = true; }                        selectLayerByIndex(selectedLayers[i], add);                    }                    break;                default:                    // Nombre                    allLayers = [];                    _layers = [];                    // Si el query tiene un &                    if (selector.startsWith("&")) {                        traverseLayersAMFlat(fillArray);                        // Filter adjustement layers                        len = allLayers.length;                        for (i=0; i<len; i++) {                            if (isMatch(selector, allLayers[i].name)) {                                _layers.push(allLayers[i]);                            }                        }                    } else if(selector.startsWith("$") && selector.endsWith("$")) {                        var selName = selector.slice(1, selector.length-1);                        _layers.push( app.activeDocument.layerSets[selName] );                    } else {                        traverseLayersAMFlat(fillArray);                        len = allLayers.length;                        for (i=0; i<len; i++) {                            if(allLayers[i].name == selector) {                                _layers.push(allLayers[i]);                            }                        }                    }            }        }        if (typeof selector == "object") {            _layers = [];            if (selector.typename == "psdQuery") {                for (i=0; i<selector.length; i++) {                    if (selector.layers[i] !== undefined) {                        _layers.push(selector.layers[i]);                    }                }            } else {                _layers = [];                _layers.push(selector);            }        }        // Copy into 'this'        this.layers = _layers.slice();        // Return self object        return this;    };    /* @psdQuery API */    psdQuery.fn = PSDQUERY.trototype = {        /* @PRIVATE METHODS */        /**         * Compara dos objetos de color, un objeto introducido por el usuario y otro que devuelve la app         * @param {object} fromUser Un objeto tipo JSON con la información rgb del color del usuario         * @param {object} fromApp Un objeto tipo JSON con la información rgb del color de la app         * @return {boolean} Devuelve true si son iguals y false de cualquier otr modo         */        compareColors: function(fromUser, fromApp) {            var match = false;            var appred, appgreen, appblue;            var usrred, usrgreen, usrblue;            appred = parseInt(fromApp.red);            appgreen = parseInt(fromApp.green);            appblue = parseInt(fromApp.blue);            usrred = fromUser.red;            usrgreen = fromUser.green;            usrblue = fromUser.blue;            if (appred == usrred && appgreen == usrgreen && appblue == usrblue) {                    match = true;            }            return match;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isLayerKind: function (layer, layerKind) {           return layer.kind == layerKind;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isLayerType: function (layer, layerTypeName) {            return layer.typename == layerTypeName;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isObjectType: function (object, objectType) {            return object == objectType;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isBackgroundLayer: function(layer) {            return layer.isBackgroundLayer;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isAdjustementLayer: function(layer) {            if (                layer.kind == LayerKind.BLACKANDWHITE ||                layer.kind == LayerKind.BRIGHTNESSCONTRAST ||                layer.kind == LayerKind.CHANNELMIXER ||                layer.kind == LayerKind.COLORBALANCE ||                layer.kind == LayerKind.COLORLOOKUP ||                layer.kind == LayerKind.CURVES ||                layer.kind == LayerKind.EXPOSURE ||                layer.kind == LayerKind.GRADIENTFILL ||                layer.kind == LayerKind.GRADIENTMAP ||                layer.kind == LayerKind.HUESATURATION ||                layer.kind == LayerKind.INVERSION ||                layer.kind == LayerKind.LEVELS ||                layer.kind == LayerKind.PATTERNFILL ||                layer.kind == LayerKind.PHOTOFILTER ||                layer.kind == LayerKind.POSTERIZE ||                layer.kind == LayerKind.SELECTIVECOLOR ||                layer.kind == LayerKind.SOLIDFILL ||                layer.kind == LayerKind.THRESHOLD ||                layer.kind == LayerKind.VIBRANCE            ) {                return true;            } else {                return false;            }        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isLayerSet: function(layer) {            return layer.typename == "LayerSet";         },         /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isTextLayer: function(layer) {            return layer.kind == LayerKind.TEXT;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isPointTextLayer: function(layer) {            return layer.kind == LayerKind.TEXT && layer.textItem.kind == TextType.POINTTEXT;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isParagraphTextLayer: function(layer) {            return layer.kind == LayerKind.TEXT && layer.textItem.kind == TextType.PARAGRAPHTEXT;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isVectorLayer: function(layer) {            return layer.kind == LayerKind.SOLIDFILL;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isArtLayer: function(layer) {            return layer.typename == "ArtLayer";        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isSmartObjectLayer: function(layer) {            return layer.kind == LayerKind.SMARTOBJECT;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isNormalLayer: function(layer) {            return layer.kind == LayerKind.NORMAL;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isShapeLayer: function(layer) {            var ref = new ActionReference();            app.activeDocument.activeLayer = layer;            ref.putEnumerated( charIDToTypeID('Lyr '),charIDToTypeID('Ordn'),charIDToTypeID('Trgt') );            desc =  executeActionGet(ref);            if(!desc.hasKey(stringIDToTypeID('adjustment'))){                return false;            }            if(desc.getBoolean(stringIDToTypeID('hasVectorMask' )) === true) {                return true;            }            return false;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        __bitmapLayerBoundsZero: function(layer) {            var bounds = layer.bounds;            if (bounds[0] === 0 && bounds[1] === 0 && bounds[2] === 0 && bounds[3] === 0) {                return true;            } else {                return false;            }        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        parentIsLocked: function(layer) {            var parent = layer.parent;            if (parent.typename == "LayerSet") {                if (parent.allLocked) {                    return true;                }            }            return false;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isRealAllLocked: function(layer) {            if (this.parentIsLocked(layer)) {                layer.parent.allLocked = false;                var realStatus = layer.allLocked;                layer.parent.allLocked = true;                return realStatus;            } else {                return layer.allLocked;            }        },        /* @LOOP METHODS */        /**         * Itera por cada uno de los elementos previamente seleccionados y devuelve el elemento         * @param {function} callback Una función a la que each llama por cada iteración         * @return {this} Devuelve this         */        each: function(callback) {            for(var i = 0; i < this.layers.length; ++i) {                callback.call(this.layers[i], i);            }            return this;        },        /**         * Itera por cada uno de los elementos filtrando los que devuelvan true         * @param {function} callback Una función a la que filter llama por cada iteración         * @return {this} Devuelve this         */        filter: function(callback) {            var r = [];            var k;            for(var i = 0; i < this.layers.length; ++i) {                k = callback.call(this.layers[i], i);                if (k){                    r.push(this.layers[i]);                }            }            this.layers = r.slice();            return this;        },        /* @FILTER METODS */        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isLocked: function(neg) {            if (neg === undefined) neg = true;            var _layers = [];            for (var i=0; i<this.layers.length; i++) {                if (neg) {                    if (this.layers[i].allLocked === true) {                        _layers.push(this.layers[i]);                    }                } else {                    if (this.layers[i].allLocked === false) {                        _layers.push(this.layers[i]);                    }                }            }            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isReallyLocked: function() {            var _layers = [];            for (var i=0; i<this.layers.length; i++) {                if (this.isRealAllLocked(this.layers[i])) {                    _layers.push(this.layers[i]);                }            }            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        childs: function() {            var _layers = [];            var parent = this.layers[0];            var childs = parent.layers;            if (parent.typename == "LayerSet") {                // FIll allLayres array;                var len = childs.length;                for (i=0; i<len; i++) {                    _layers.push(childs[i]);                }            }            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        getLayersRecursive: function(target) {            var layerArray = target.layers;            var len = layerArray.length;            for (var i=0; i<len; i++) {                if (layerArray[i].typename == "LayerSet") {                    this.layers.push(layerArray[i]);                    this.getLayersRecursive(layerArray[i]);                } else {                    this.layers.push(layerArray[i]);                }            }        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        descendants: function() {            var parent = this.layers[0];            this.layers = [];            this.getLayersRecursive(parent);            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isEmpty: function() {            var _layers = [];            for (var i=0; i<this.layers.length; i++) {                if (this.layers[i].typename == "LayerSet") {                    if (this.layers[i].layers.length < 1) {                        _layers.push(this.layers[i]);                    }                } else {                    // Normal layer                    if (this.layers[i].kind == LayerKind.NORMAL && this.__bitmapLayerBoundsZero(this.layers[i])) {                        _layers.push(this.layers[i]);                    }                    // Text layer                    if (this.layers[i].kind == LayerKind.TEXT && this.layers[i].textItem.contents.length === 0) {                        _layers.push(this.layers[i]);                    }                }            }            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        isHidden: function() {            var _layers = [];            for (var i=0; i<this.layers.length; i++) {                if (this.layers[i].visible === false) {                    _layers.push(this.layers[i]);                }            }            this.layers = _layers.slice();            return this;        },        /* @ACTION METHOS */        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        show: function() {            for (var i=0; i<this.layers.length; i++) {                this.layers[i].visible = true;            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        hide: function() {            for (var i=0; i<this.layers.length; i++) {                try {                    this.layers[i].visible = false;                } catch(e){}            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        lock: function() {            for (var i=0; i<this.layers.length; i++) {                this.layers[i].allLocked = true;            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        unlock: function() {            for (var i=0; i<this.layers.length; i++) {                this.layers[i].allLocked = false;            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        rename: function(name) {            for (var i=0; i<this.layers.length; i++) {                if (!this.isBackgroundLayer(this.layers[i])) {                    this.layers[i].name = name;                }            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        duplicate: function(name) {            for (var i=0; i<this.layers.length; i++) {                var newLayer = this.layers[i].duplicate(this.layers[i], ElementPlacement.PLACEBEFORE);                newLayer.name = name;            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        remove: function() {            for (var i=0; i<this.layers.length; i++) {                try {                    if (this.layers[i].allLocked) {                        this.layers[i].allLocked = false;                    }                    this.layers[i].remove();                } catch(e) {}            }            this.layers = [];        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        visible: function(val) {            var layers = this.layers;            var len = this.layers.length;            var layer = this.layers[0];            if (val != undefined) {                for (var i=0; i<len; i++) {                    layers[i].visible = val;                }            } else {                return layer.visible;            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        opacity: function(val) {            var layers = this.layers;            var len = this.layers.length;            var layer = this.layers[0];            if (val) {                if (val > 100) {                    val = 100;                } else if (val < 0) {                    val = 0;                }                for (var i=0; i<len; i++) {                    if (layers[i].allLocked === false) {                        layers[i].opacity = val;                    }                }            } else {                return parseInt(Math.round(layer.opacity));            }            return this;        },        /* @GET VALUE METHODS */        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        fontSize: function() {            return this.layers[0].textItem.size.as("px");        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        path: function () {            try {                return this.layers[0].path;            } catch(e) {}        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        backgroundColor: function (c) {            if (c === undefined) {                return this.app.backgroundColor;            } else {                this.app.backgroundColor = c;                return this;            }        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        foregroundColor: function (c) {            if (c === undefined) {                return this.app.foregroundColor;            } else {                this.app.foregroundColor = c;                return this;            }        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        layerFX: function(fxs) {            var layerStyleObj;            var layerEffectsObj;            var len = fxs.length();            var match;            var inputPropValue;            var layerPropValue;            var _layers = [];            // Pasamos por cada capa            for (var i=0; i<this.layers.length; i++) {                app.activeDocument.activeLayer = this.layers[i];                layerStyleObj = jamStyles.getLayerStyle();                layerEffectsObj = layerStyleObj.layerEffects;                match = false;                // Pasamos por cada efecto indicado                /*                    Usamos una función anónuima para poder salir de varios loops                    en cuanto una propiedad de false (ya sea que no existe o no                    coincide                */                (function() {                    for (var fx in fxs) {                        if (fx == "dropShadow" || fx == "frameFX") {                            // recorrido por propiedades indicadas en el query                            for (var prop in fxs[fx]) {                                try {                                    inputPropValue = fxs[fx][prop];                                    layerPropValue = layerEffectsObj[fx][prop];                                } catch (e) {                                    /*                                        Si no existe la propiedad le asignamos                                        -1 para que la comprobación de false y                                        salgamos del bucle                                    */                                    inputPropValue = 0;                                    layerPropValue = -1;                                }                                /*                                    Comprobamos si las propiedades indicadas por                                    el query son iguales que las existentes en                                    la capa.                                    Si la propiedad es un SolidColor, usamos una                                    funcion.                                */                                if (prop == "color") {                                    if (PSDQUERY.prototype.compareColors(inputPropValue, layerPropValue)) {                                        match = true;                                    } else {                                        match = false;                                        return;                                    }                                } else {                                    if (inputPropValue == layerPropValue) {                                        match = true;                                    } else {                                        match = false;                                        return;                                    }                                }                            }                        }                    }                })();                // Si todo ha ido bien, incluimos la capa en _layers;                if (match) {                    _layers.push(this.layers[i]);                }            }            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        setLayerFX: function(fxs) {            var layerFXObject = {                "layerEffects":{                }            };            // Layer by layer            for(var i=0; i<this.layers.length; i++) {                // LayerFX by LayerFX                for (var fx in fxs) {                    if (fx != "length") {                        for(var prop in fxs[fx]) {                            try {                                layerFXObject.layerEffects[fx] = fxs[fx];                                layerFXObject.layerEffects[fx][prop] = fxs[fx][prop];                            } catch(e) {}                        }                    }                }                app.activeDocument.activeLayer = this.layers[i];                jamStyles.setLayerStyle(layerFXObject);            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        UISelect: function() {            var ids = [];            var i, count, add;            // Get Layers index            for (i=0; i<this.layers.length; i++) {                app.activeDocument.activeLayer = this.layers[i];                ids.push(getIndexFromSelectedLayers());            }            // Select layers by index (adding)            add = false;            count = ids.length;            for (i=0; i<count; i++) {                if (i>0) { add = true; }                selectLayerByIndex(parseInt(ids[i]), add);            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        groupIn: function (groupName) {            groupName = groupName || undefined;            // create new group and rename it            var newGroup = app.activeDocument.layerSets.add();            // Use own psdQuery methods            $$(newGroup).rename(groupName);            // Move layers and groups into new group            for (i=0; i<this.layers.length; i++) {                moveTo(this.layers[i], newGroup);            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        append: function(theChilds) {            for (var i=0; i<theChilds.layers.length; i++) {                moveTo(theChilds.layers[i], this.layers[0]);            }            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        addGroup: function(name) {            // Add group to existing group or root hierarchy            _layers = [];            var firstItem = this.layers[0];            var newGroup;            if (firstItem.typename == "LayerSet") {                newGroup = this.layers[0].layerSets.add();            } else {                newGroup = app.activeDocument.layerSets.add();            }            if (name) {                newGroup.name = name;            }            _layers.push(newGroup);            this.layers = _layers.slice();            return this;        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        addBitmapLayer: function(userInput) {        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        addShapeLayer: function(userInput) {        },        /**         * ...         * @param {...} paramName ...         * @return {...} ...         */        addTextLayer: function(userInput) {            // Primero creamos lo que viene siendo la capa de texto            var textLayer = app.activeDocument.artLayers.add();            textLayer.kind = LayerKind.TEXT;            app.activeDocument.activeLayer = textLayer;            var psdQueryOptions = {                "textKey": userInput.text,                "antiAlias": "antiAliasCrisp",                "textType": userInput.textType,                "orientation": "horizontal",                "fontPostScriptName": userInput.font,                "size": userInput.size,                "color": userInput.color,                "alignment": "center"            }            var mixOptions = mixObjects(userInput, psdQueryOptions);            // Construimos el objeto de style            var layerText =            {                "layerText":                {                    "textKey": userInput.text,                    "antiAlias": "antiAliasCrisp",                    "textShape":                    [                        { "textType": userInput.textType, "orientation": "horizontal" }                    ],                    "textStyleRange":                    [                        {                            "from": 0,                            "to": userInput.text.length,                            "textStyle":                            {                                "fontPostScriptName": userInput.font,                                "size": userInput.size,                                "color": userInput.color                            }                        }                    ],                    "paragraphStyleRange":                    [                        {                            "from": 0,                            "to": userInput.text.length,                            "paragraphStyle": { "alignment": "center" }                        }                    ]                },                "typeUnit": "pixelsUnit"            };            // Aplicamos            jamText.setLayerText(layerText);            this.layers = [textLayer];            return this;        }    };})();