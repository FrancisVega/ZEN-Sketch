/*
  global
  NSPredicate,
  MSLayerGroup,
  MSLayerArray,
  MSRectangleShape,
  MSRect,
  NSMakeRect,
  MSShapeGroup,
  MSLayerMovement,
  MSColor,
  MSColor,
  log,
  context
*/

var onRun = function(context) {


  //
  // Functions
  //

  // Find layers by name
  const findLayersByName = (name, scope) => scope.filteredArrayUsingPredicate(
    NSPredicate.predicateWithFormat("name == %@",name)
  );
  // Get min value from array
  const min = arr => Math.min.apply(Math, arr);
  // Min (y) pos from layers
  const minY = layers => min(layers.slice().map(layer => layer.frame().y()));
  // Min (x) pos from layers
  const minX = layers => min(layers.slice().map(layer => layer.frame().x()));
  // Get margin data from marginbox layer
  const getData = layer => layer.name().split(/:/g).pop().trim();
  // Get layers bounds
  const getLayerBounds = layers => MSLayerGroup.groupBoundsForContainer(
    MSLayerArray.arrayWithLayers(layers)).size;
  // Create rectangle type layer
  const createRectLayer = (name, x, y, width, height, parent) => {
    if(parent.class() == "MSLayerGroup") {
      const rectShape = MSRectangleShape.alloc().init();
      rectShape.frame = MSRect.rectWithRect(NSMakeRect(x,y,width,height));
      const shapeGroup = MSShapeGroup.shapeWithPath(rectShape);
      shapeGroup.name = name;
      parent.addLayers([shapeGroup]);
      return shapeGroup;
    }
  }


  //
  // Consts
  //

  const MARGIN_LAYER_NAME = 'marginbox';
  const MARGIN_BORDER_COLOR = { r:255, g:0, b:128, a:0.5 };
  const MARGIN_FILL_COLOR = { r:255, g:0, b:128, a:0.05 };


  //
  // Main
  //

  // User seleccion
  const selection = context.selection;

  for (let i=0; i<selection.length; ++i) {
    try {
      const keyLayer = selection[i];
      const childsOfKeyLayer = keyLayer.layers();

      // Marginbox layer
      var marginbox = findLayersByName(MARGIN_LAYER_NAME, childsOfKeyLayer).firstObject();

      // Filter marginbox layer
      const validLayers = childsOfKeyLayer.slice().filter(layer => layer.name() != MARGIN_LAYER_NAME);

      // Boundingbox of all child layers
      const bounds = getLayerBounds(validLayers);
      const heightBoundingBox = bounds.height;
      const widthBoundingBox = bounds.width;

      if(marginbox == null) {
        marginbox = createRectLayer (MARGIN_LAYER_NAME, 0, 0, 1, 1, keyLayer);
        MSLayerMovement.moveToBack([marginbox]);

        // Add fill
        marginbox.style().addStylePartOfType(0);
        // Add border
        marginbox.style().addStylePartOfType(1);
        // Get fill
        const originalFill = marginbox.style().fills().firstObject();
        // Get border
        const originalBorder = marginbox.style().borders().firstObject();
        // Set fill
        const marginFillColor = MSColor.colorWithRed_green_blue_alpha(
          MARGIN_FILL_COLOR.r, MARGIN_FILL_COLOR.g, MARGIN_FILL_COLOR.b, MARGIN_FILL_COLOR.a
        );
        originalFill.color = marginFillColor;
        // Set border
        const marginBorderColor = MSColor.colorWithRed_green_blue_alpha(
          MARGIN_BORDER_COLOR.r, MARGIN_BORDER_COLOR.g, MARGIN_BORDER_COLOR.b, MARGIN_BORDER_COLOR.a
        );
        originalBorder.color = marginBorderColor;
      }

      // Reset marginbox layer positions
      marginbox.frame().y = minY(validLayers);
      marginbox.frame().x = minX(validLayers);

      // Get margin values
      const mData = getData(keyLayer);

      let result
      if (mData.match(/[a-z|A-Z]/g) == null) {
        // num
        let r1 = mData.split(/\s/g);
        if (r1.length == 1) {
          result = [r1[0], r1[0], r1[0], r1[0]];
        } else if (r1.length == 2) {
          result = [r1[0], r1[1], r1[0], r1[1]];
        } else {
          result = r1;
        }
      } else {
        // alphanum
        let positions = mData.slice().split(/\s/g).map(x => x.match(/[a-z|A-Z]/g).join(""));
        let values = mData.slice().split(/\s/g).map(x => x.match(/\d+/g));
        let r2 = ["0", "0", "0", "0"];
        for (let i=0; i<positions.length; ++i) {
          if(positions[i].toLowerCase() == "t") { r2[0] = values[i] }
          if(positions[i].toLowerCase() == "r") { r2[1] = values[i] }
          if(positions[i].toLowerCase() == "b") { r2[2] = values[i] }
          if(positions[i].toLowerCase() == "l") { r2[3] = values[i] }
        }
        result = r2;
      }

      result = result.map(x => Number(x));

      // Marginbox position
      marginbox.frame().y = marginbox.frame().y() - result[0];
      marginbox.frame().x = marginbox.frame().x() - result[3];
      marginbox.frame().height = heightBoundingBox + result[0] + result[2];
      marginbox.frame().width = widthBoundingBox + result[1] + result[3];

      // Fit size group
      keyLayer.resizeToFitChildrenWithOption(true);
    } catch(e) {
      log(`Error ${e}`);
    }
  }
}
